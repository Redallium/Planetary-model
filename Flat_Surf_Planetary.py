#Программа для рассчета распределения толщины покрытия на плоской детали при покрытии с использованием планетарной модели
import math
sqrt = math.sqrt
sin = math.sin
cos = math.cos
pi = math.pi

H = 535          #Высота планет относительно испарителя
R = 100          #Радиус детали
d = 195          #Расстояние от главной оси камеры до центра планеты
L = 200          #Расстояние от главной оси камеры до испарителя
N = 11           #Число контрольных точек на одном из радиусов планеты
w1 = pi / 21     #Угловая скрость вращения главной оси камеры(рад/c)
w2 = pi / 3      #Угловая скрость вращения оси планеты(рад/c)
T = 84 	         #Время работы машины(c) (w1 * T  = 2*pi*k & w2 * T = 2*pi*m, где k и m - натуральные числа)
alpha = 1        #Степень косинуса угла вылета из испарителя(Параметр, описывающий диаграмму направленности испарителя)
Thickness = []   #Список толщин слоя на контрольных точках

try:
	F = open("Graph_Flat_Surf_Planetary.txt", "w")
except IOError:
	print("File reading error\n")         #Открытие файла для записи распределения толщины по радиусу с исключением на возможную ошибку открытия файла
	exit()

N_dt = 10000    #Число дискретезации процесса(Число исследуемых моментов времени)
TimeMoments = [t / N_dt for t in  range(0, N_dt * T, T)]    #Список всех исследуемых моментов времени

for n in range(N):       #Цикл по всем контрольным точкам
	Thickness.append(0)     #Заполнение нулями списка толщин

	r = R * (n / (N-1))     #Радиус вращения n-ой контрольной точки вокруг оси детали
	dz = H                  #Разница z - овых координат n - ой контрольной точки и испарителя.
	for t in TimeMoments:                  #Цикл по всем моментам времени
		dx = d + r * cos(w2 * t) - L * cos(w1 * t)     #Разница x - овых координат n - ой контрольной точки и испарителя
		dy = r * sin(w2 * t) - L * sin(w1 * t)               #Разница y - овых координат n - ой контрольной точки и испарителя
		l = sqrt(dx * dx + dy * dy + dz * dz)                #Формула для расстояния между испарителем и контрольной точкой n
		dh = (((dz / l) ** alpha) * (dz / l)) / (l * l)                     #Формула для наростающей толщины (пропорциональна косинусу угла вылета из испарителя и косинусу угла падения на деталь и обратно пропорцилнальна квадрату расстояния от испарителя до контрольной точки)
		Thickness[n] += dh                                   #Наростание толщины

max_thickness = max(Thickness)
for n in range(N):     #Нормируем толщины и переводим их в относительные величины
	Thickness[n] = Thickness[n] / max_thickness
	F.write(str(round(R * (n / (N-1)), 3)) + ' ' + str(Thickness[n]) + '\n')    #Запись в файл радиуса вращения n - ой контрольной точки и толщина покрытия на этой точке
print("Толщина покрытия равномерна с максимальным отклонением", 100 - min(Thickness) / max(Thickness) * 100, '%')
F.close()
print("Successful\n")